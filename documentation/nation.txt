#!todo

#have selection of animal icons
#population census with diseases and population boons
#diplomatic mean neutral or good relations
#conflicts happen with population loss depending on military level
#unions can happen if economic level is greater with good relations
#migrations happen at low food
#population increase from neighbour migration loss
#types of nations regular nation(player)/ south nation(strong domestic)/ east nation (strong aggressor)/ west nation(weak agressor)
#during conflict skirmish first happen then battle then pillage end 2 happen same time 

#!full
from blessed import Terminal
from opensimplex import OpenSimplex
import random, math, time, psutil, os, threading
term= Terminal()

class variables:
 running=True
 gridX=100;gridY=term.height-2+2;
 scale= 5.0;threshold=-0.53;
 debug= 10
 noise = OpenSimplex(seed=random.randint(0, 10000))
 viewX=0;viewY=0;viewW=55;viewH=term.height-2
 biasLand= [[0.15,0.29],[0.13,0.7],[0.3,0.3],[0.62,0.4]]
 biasWater=[[0.85,0.6]]
 lands=[]
 verticalLand=2.8
 biasContinent=2
 units=[]
 typed = [""]*viewH
 typed[1]= "help"
 previousText="help"
 usageOn=False
 move1=0
v= variables()

class unit:
 def __init__(self,loc=[0,0],pop=10):
  self.loc=loc
  self.pop=pop
v.units.append(unit([int(v.biasLand[1][0]*v.gridX), int(v.biasLand[1][1]*v.gridY)]))

def printUsage():
 while True:
  if v.usageOn:
   proc = psutil.Process(os.getpid())
   v.typed[2]= f"{proc.memory_info().rss // 1024000}MB/{proc.cpu_percent(interval=0.1)/os.cpu_count():.1f}cpu"
  time.sleep(2)

def biasFactor(x,y):
 factor=0
 for bx,by in v.biasLand:
  px=int(bx*v.gridX)
  py=int(by*v.gridY)
  dist= math.hypot(x-px,(y-py)*v.verticalLand)
  factor+= max(0, 1-(dist/15))  
 for bx,by in v.biasWater:
  px=int(bx*v.gridX)
  py=int(by*v.gridY)
  dist= math.hypot(x-px,(y-py)*v.verticalLand)
  factor-= max(0, 1-(dist/15))
 return factor

def landCreate():
 v.lands=[]
 for y in range(v.gridY):
  array=[]
  for x in range(v.gridX):
   n = v.noise.noise2(x / v.scale, y / v.scale)
   n-= biasFactor(x,y)* v.biasContinent
   if n < v.threshold and y != v.gridY - 1:
    array.append(1)
   else:
    array.append(0)
  v.lands.append(array)

def landRow(y,ux=-1):
 if ux==-1:
  row= ""
  for ox in range(v.viewW):
   x=v.viewX+ox
   wrappedX = x % v.gridX
   if v.lands[y][wrappedX]:
    row += term.on_color_rgb(31, 141, 11)(" ")
   else:
    row+= term.on_color_rgb(4, 14, 111)(" ")
  return row
 else:
  if v.lands[y][ux]:
   return term.on_color_rgb(31, 141, 11)("O")
  else:
   return term.on_color_rgb(4, 14, 111)("O")

def commandFuncs():
 if v.typed[0]=="":
  if v.previousText!="":
   v.typed[0]= v.previousText
 v.previousText= v.typed[0]

 if v.typed[0]=="quit":
  v.running=False
 elif v.typed[0]=="help":
  v.typed[0]="help-> arrowKeys/'quit'/'help2'"
 elif v.typed[0]=="help2":
  v.typed[0]="help2-> "
 elif v.typed[0]=="reset":
  v.noise = OpenSimplex(seed=random.randint(0,  10000))
  landCreate()
 elif v.typed[0]=="debug":
  v.typed[0]=f"debug-> {v.scale,v.threshold,v.debug}"
 elif v.typed[0]=="speed":
  v.usageOn=not v.usageOn
 else:
  v.typed[0]+=" not found"

def graphicsManager(x=-1, y=v.viewH):
    v.move1+=1
    if x == -1:
        # Step 1: Build a 2D list of full tile strings
        frame = []
        for ny in range(y):
            row = []
            for ox in range(v.viewW):
                gx = v.viewX + ox
                gy = v.viewY + ny
                wrappedX = gx % v.gridX
                if v.lands[gy][wrappedX]:
                    row.append(term.on_color_rgb(31, 141, 11)(" "))
                else:
                    row.append(term.on_color_rgb(4, 14, 111)(" "))
            frame.append(row)

        # Step 2: Insert units directly into the frame
        for thisUnit in v.units:
            newX = thisUnit.loc[0] - v.viewX
            newX = newX % v.gridX
            newY = thisUnit.loc[1] - v.viewY
            if 0 <= newX < v.viewW and 0 <= newY < v.viewH:
                frame[newY][newX] = landRow(thisUnit.loc[1], thisUnit.loc[0]+v.move1)  # full ANSI "O"

        # Step 3: Print the frame
        for i, row in enumerate(frame):
            print(term.move_xy(0, i + 1) + "".join(row), end="")

    elif x >= v.viewW:
        for ny in range(y):
            print(
                term.move_xy(x, ny + 1)
                + v.typed[v.viewH - 1 - ny][-term.width + v.viewW + 1:]
                + term.clear_eol,
                end=""
            )
    else:
        print(term.move_xy(x, y + 1) + landRow(y + v.viewY, x), end="")

landCreate()
t= threading.Thread(target=printUsage, daemon=True)
t.start()
graphicsManager()
graphicsManager(v.viewW)
with term.cbreak(), term.hidden_cursor():
 while v.running:
  v.viewX= v.viewX % v.gridX

  graphicsManager()
  graphicsManager(v.viewW)

  key = term.inkey(timeout=0.05)
  if key:
   if key.name == "KEY_ENTER" or key == "\n":
    commandFuncs()
    for i in range(len(v.typed)-1, 0, -1):
     v.typed[i] = v.typed[i-1]
    v.typed[0] = ""
   elif key.name == "KEY_BACKSPACE":
    v.typed[0] = v.typed[0][:-1]
   elif key.name == "KEY_LEFT":
    v.viewX -= 5
   elif key.name == "KEY_RIGHT":
    v.viewX += 5
   elif key.name == "KEY_UP":
    v.viewY = max(0, v.viewY - 1)
   elif key.name == "KEY_DOWN":
    maxScroll = max(0, v.gridY - v.viewH)
    v.viewY = min(maxScroll, v.viewY + 1)
   else:
    v.typed[0] += key

#!v2
import sys,os,random,time,termios, tty, math
import shutil, traceback
from opensimplex import OpenSimplex
from pynput import keyboard
from pynput.keyboard import Key, Listener

commands= ["help", "pause", "census", "focus", "diplomacy", "defensive", "expansive", "militaristic", "new", "multiplayer"]
aliases= ["h", "p", "c", "f", "d", "def", "exp", "mil"]#ends at militaristic
allTexts=[
["controls:","wasd/qe/enter","1-notes 2-population", "3-influence 4-groups", "5-builds", "menu:", "new","multiplayer", "load","commands:"]+ 
commands[:5]+ ["aliases:"]+ aliases+ ["!advance help!:","investment-","## [Y/n] to enable", "eg- (1 y)", "[citizens,influence,", "military,time]","build-","(maintained-_ mound-A farm-#)"],#state0
[],
["census:", "citizens-", "military-", "diseased-", "investments-"], #state2
["focuses:", "focus-", "investments-"],
["diplomacy:", "nations-", "investments-"],
["End:", "[citizens,military", "influence](peak)-", "(current)-", "formula:", "(ci/2+m)*i | peak/3+current"] #state5
]

codeInv=[[0.1,0.2,0.0,10], [0.2,0.1,0.1,15], [0.1,0.1,0.0,9], [0.1,0.0,0.2,4], [0.2,0.2,0.3,10], [0.3,0.1,0.1,20],[0.3,0.0,0.0,15]]   #treaty envoy healer ceremony raid union mound
reset = "\033[0m"

class variables():
 buffer=[];
 xy=[70,20]
 seed=-1
 scale=3.65
 threshold=11;
 playerConsole= False
 mapScroll=[0,0]
 mapSize=[70,20]
 console=""
 windowState=0
 windowText=[""]
 cells=[]
 delay=0
 mapMode= 0 #0-greenBlue, 1-popDensity (light-dark), 2-influence(black-purple), 3-groups (rgb or black), 4-builds
 average=0
 windowScroll=0
 difficulty=5
 speed=1
 pId=0
 robots=[]
 areas=[]
 players=[]
 chunkSize=5
 notifications=[] #[location,timer,char]
 pause=False
 debugText=0
 timeLeft= 3
 history=[[""]*10,0]
v=variables()

class cell():
 def __init__( self,po=80, gro=[0.0,0.0,0.0]):
  self.outGroups= [0.0,0.0,0.0]
  self.improvement=0 #0-none 1-maintained 2-mound 3-farm
  self.population=po
  self.inGroups=gro

class player():
 def __init__(self,gro=0, ro=True):
  self.disease=[0,0] #0-none 1-mild 2-heavy
  self.focus=1 #0-defensive 1-expansive 2-military
  self.citizens=0
  self.military=0
  self.investments=[]
  self.influences=[]
  self.relations=[]
  self.availableLands=[]
  self.group=gro
  self.robot=ro
  self.claims=[[],[]] #0-rival 1-treaty
  self.peaks=[0,0,0] #0-pop 1-mil 2-inf

class investment():
 def __init__( self, na="", co=0, wi=0):
  self.enabled=False
  self.value=0
  self.name=na
  allDemand=[]
  for i in range(3):
   idx=0.0
   if codeInv[co][i]!=0.0:
     idx= random.uniform(codeInv[co][i]-0.05, codeInv[co][i])
   allDemand.append(idx)
  allDemand.append(codeInv[co][3])
  self.demands= allDemand#0-pop 1-inf 2-mil 3-time
  self.window=wi
  self.code=co

def pickColor(r, g, b):
 return f"\033[48;2;{r};{g};{b}m"

def disableControls():
 old_settings = termios.tcgetattr(sys.stdin)
 iflag, oflag, cflag, lflag, ispeed, ospeed, cc = termios.tcgetattr(sys.stdin)
 
 iflag &= ~termios.IXON
 iflag &= ~termios.ISTRIP
 iflag &= ~termios.ICRNL
 iflag &= ~termios.INLCR
 iflag &= ~termios.IGNCR
 new_settings = [iflag, oflag, cflag, lflag, ispeed, ospeed, cc]
 termios.tcsetattr(sys.stdin, termios.TCSANOW, new_settings)
 return old_settings

def convertCell(set=0, idx=0):
 if set==0: #cellToGrid
  chunkX = (idx % v.mapSize[0]) // v.chunkSize
  chunkY = (idx // v.mapSize[0]) // v.chunkSize
  areaIndex = chunkY * (v.mapSize[0] // v.chunkSize) + chunkX
  return areaIndex
 elif set==1 or set==2: #gridToCell/ all cells
  chunkX = idx % (v.mapSize[0] // v.chunkSize)
  chunkY = idx // (v.mapSize[0] // v.chunkSize)
  cellX = chunkX * v.chunkSize
  cellY = chunkY * v.chunkSize
  index= cellY * v.mapSize[0] + cellX
  if set==1:
   return index
  total=[]
  for y in range(index//v.mapSize[0], index//v.mapSize[0]+5):
   for x in range(index%v.mapSize[0], (index+v.chunkSize)%v.mapSize[0]):
    cellIdx=y* v.mapSize[0]+ x
    if v.cells[cellIdx]:
     total.append(cellIdx)
  return total

def updateVar(index=0,val=[]):
 if index==1:
  v.players[val[0]].influences. append([val[1],val[2]])
  areaIndex = convertCell(0,val[2])
  if not v.pId in v.areas[areaIndex] and len(v.areas[areaIndex])>0:
   v.notifications.append( [val[2],9,'D'])
   for i in range(len(v.areas[areaIndex])):
    relateNum= v.players[v.pId].relations [v.areas[areaIndex][i]]
    if relateNum==-1.0:
     v.players[v.pId].relations [v.areas[areaIndex][i]]=0.4
     v.players[v.pId].investments. append(investment(f"n{v.areas[areaIndex][i]} treaty", 0, 2))
     v.players[v.pId].investments. append(investment(f"n{v.areas[areaIndex][i]} envoy", 1, 2))
     v.players[v.pId].claims[0] .append(v.areas[areaIndex][i])

  v.areas[areaIndex].append(val[0])

def printLine(y,text=""):
 print(f"\033[{y+1};1H", end="")
 print("\033[K", end="")
 print(text, end="")

def drawLine(y):
 if not v.buffer[y]: return
 v.buffer[y]=False
 line= ""
 if y<v.xy[1]-1:
  windowI=0
  for x in range(v.xy[0]):
   if not (y<int(v.xy[1]*0.5) and int(v.xy[0]*0.5)<x and v.windowState>-1):
    if (0 <= x + v.mapScroll[0] < v.mapSize[0] and 0 <= y + v.mapScroll[1] < v.mapSize[1]):
     index= v.mapSize[0] * (y + v.mapScroll[1]) + (x + v.mapScroll[0])
     if index < len(v.cells):
      if v.cells[index]:
       newChar=' '
       if v.mapMode==0:
        line+= pickColor(11, 111, 16)

       elif v.mapMode==1:
        green= min(255,int(88* (max(1,v.cells[index].population)/ max(v.average,1))/4))
        line+= pickColor(11, green, 16)

       elif v.mapMode==2:
        color=0    
        for i in range(len(v.players[v.pId].influences)): 
         if v.players[v.pId]. influences[i][1]== index:
          color= min(255,int(155* v.players[v.pId].influences[i][0])+6)
        line+= pickColor(color, 37, color)

       elif v.mapMode==3:
        inGro=v.cells[index].inGroups
        total = sum(inGro)
        r = int((inGro[0] / total) * 211)
        g = int((inGro[1] / total) * 211) 
        b = int((inGro[2] / total) * 211)
        line += pickColor(r, g, b)

       elif v.mapMode==4:
        newChar=[' ', '_', 'A', '#'] [v.cells[index].improvement]
        line+= pickColor(11, 111, 16)

       if v.mapMode==0:
        for i in range(len(v.notifications)):
         if index== v.notifications[i][0]:
          newChar=v.notifications[i][2]
       line+=newChar
      else:
       line+= pickColor(11, 22, 111)
       line+=' '
   else:
    if len(v.windowText)>y:
     if windowI==0: line+=reset
     if len(v.windowText[y])>windowI:
      line+=v.windowText[y][windowI]
      windowI+=1
 else:
  if v.playerConsole:
   line+= v.console 
  else:
   pauseText=""
   if v.pause and (v.delay//80)%4!=0: pauseText="!"
   pl= v.players[v.pId]
   dis=""
   if pl.disease[0]==2:
    dis="!!!"
   line+= f"{pauseText}c:{pl.citizens}/m:{pl.military}/f:{pl.focus}/t:{len(pl.influences)}/{dis}d:{pl.disease[0]}/e:{v.timeLeft}"
 line+=reset
 printLine(y,line)
 print( f"\033[{v.xy[1]};{len(v.console)+1}H", end='', flush=True)
 sys.stdout.flush()

def createMap(see=-1):
 v.players= [player(2,False)]
 v.cells, v.notifications= [],[]
 if see==-1:
  see= random.randint(0, 10000)
  v.seed= see
 noise = OpenSimplex(seed=see)
 noiseTwo= OpenSimplex(seed=see+1)
 v.areas= [[] for _ in range((v.mapSize[0]//5) * (v.mapSize[1]//5))]
 start, newRand=[0,0],[]
 v.buffer=[True]* len(v.buffer)

 for i in range(len(v.areas)//6):
  newRand.append(random.randint(0, len(v.areas)-1))

 for y in range(v.mapSize[1]):
  for x in range(v.mapSize[0]):
   n = noise.noise2(x*v.scale/v.mapSize[0], y*v.scale/v.mapSize[1])
   distance = 0
   if n > v.threshold/100:
    n2 = (max(0.05,noiseTwo.noise2( x*v.scale/v.mapSize[0]*1.8, y*v.scale/v.mapSize[1]*1.8))*110)
    dx = x - v.mapSize[0]/2
    dy = y - v.mapSize[1]/2
    distance = math.sqrt(dx*dx + dy*dy)
    angle_rad = math.atan2(dy, dx)
    groups = [
    (math.cos(angle_rad) + 1) / 2,
    (math.cos(angle_rad - 2*math.pi/3) + 1) / 2,
    (math.cos(angle_rad - 4*math.pi/3) + 1) / 2 ]
    v.cells.append(cell(int(n2),groups))
    groupValue=max(groups)
    groupI=groups.index(groupValue)
    if groupI==2:
     if start[0]<n2* groups[2]:
      start=[n2* groups[groupI], v.mapSize[0]* y+ x]
    newNum= convertCell(0,y* v.mapSize[0]+ x)
    if newNum in newRand:
     indexRand= newRand.index(newNum)
     v.areas[newNum].append(len(v.players))
     v.players.append(player(groupI))
     del newRand[indexRand]  

   else:
    v.cells.append(None)
 v.notifications. append([start[1],8,'H'])

 for i in range(len(v.players)):
  relation=-1.0
  if i==v.pId:
   relation=1.0
  v.players[v.pId].relations. append(relation)
 updateVar(1, [v.pId,0.2,start[1]])  
 v.buffer=[True]*v.xy[1]

def checkCross(index):
 current_col = index % v.mapSize[0]
 current_row = index // v.mapSize[0]
 directions = [
        (current_col + 1, current_row),
        (current_col - 1, current_row),
        (current_col, current_row + 1),
        (current_col, current_row - 1)]
 added = []
 avoid = [idx[1] for idx in v.players[v.pId].influences]
 for col, row in directions:
  if 0 <= col < v.mapSize[0] and 0 <= row < v.mapSize[1]:
   cell_idx = row * v.mapSize[0] + col
   if cell_idx < len(v.cells) and v.cells[cell_idx] and cell_idx not in avoid:
    added.append(cell_idx)
 return added

def investmentsDone(indexInv=-1):
 inv= v.players[v.pId].investments[indexInv]
 index= inv.code
 if index==0:
  idx= int(inv.name.split()[0][1:])
  if idx in v.players[v.pId].claims[0]:
   v.players[v.pId].claims[0].remove(idx)
   v.players[v.pId].claims[1].append(idx)
 if index==1 or index==0:
  idx= int(inv.name.split()[0][1:])
  v.players[v.pId].relations[idx]+= inv.val/(int(index==0)*3+1)/1000
 elif index==2:
  v.players[v.pId].disease[1]-=inv.val/300
 elif index==3:
  for i in range(len(v.players[v.pId].influences)):
   v.players[v.pId].influences+= inv.val/2000
 elif index==4:
  idx= int(inv.name.split()[0][1:])
  if 
 elif index==5:
  pass
 elif index==6:
  pass

def gameLoop():
 if v.pause: return
 if v.delay%200==0:
  v.notifications.reverse()
  for i in range(len(v.notifications)-1, -1, -1):
   v.notifications[i][1]-=1
   if v.notifications[i][1]<=0:
    del v.notifications[i]

 if v.delay%max(1,int(96*v.speed))==0:
  v.timeLeft-=1
  if v.timeLeft==0:
   v.windowState=5
   consoleShow()
  inv=v.players[v.pId].investments
  if len(inv)>0:
   for i in range(len(inv)-1, -1, -1):
    if not inv[i].enabled:
     continue
    inv[i].demands[3]-=1
    for inf in v.players[v.pId].influences:
     first= inf[0]*v.cells[inf[1]].population *inv[i].demands[0]
     second= inf[0]*inv[i].demands[1]
     third= v.players[v.pId].military*inv[i].demands[2]
     inv[i].value+= second*100+first+third*2
     v.cells[inf[1]].population-=first
     if inv[i].demands[3]<=0:
      investmentsDone(i)
      del inv[i]

 if v.delay%max(1,int(63*v.speed))==0:
  for i in range(len(v.cells)):
   if v.cells[i]:
    growth = max(1, v.cells[i].population // 100)
    v.cells[i].population = min(v.cells[i].population + growth, 9999999)

  for i in range(len(v.areas)):
   for j in range(len(v.areas[i])):
    if v.areas[i][j]>=len(v.players):
     thisGroup= v.players[v.areas[i][j]].group
     allIndexes= convertCell(2, i)
     for idx in allIndexes:
      v.cells[idx].inGroups[thisGroup]+= 0.005

  for v.players[v.pId]
  for inf in v.players[v.pId]. influences:
   v.cells[inf[1]]. inGroups[v.players[v.pId].group]+= 0.01

  v.players[v.pId].disease[1]-=1
  if v.players[v.pId].disease[1]<=0:
   v.players[v.pId].disease[0]=0

 if v.delay%max(1,int(80*v.speed))==0:
  allInf=0.0
  allCit=0
  for i in range(len(v.players[v.pId].influences)):
   val1=max(i,1) if v.players[v.pId].focus==0 else max(i,1)*2
   val2=max(i,1) if v.players[v.pId].focus==2 else max(i,1)*2
   val3= max(i,1) if v.players[v.pId].focus==1 else max(i,1)*2
   oldInf= v.players[v.pId]. influences[i].copy()

   totalMil= int(oldInf[0] * v.cells[ oldInf[1]]. population/ (val2*20))
   v.players[v.pId].military= min(9999999,v.players[v.pId].military+ totalMil)
   totalMil=int(totalMil*(val1/20))
   v.cells[oldInf[1]].population= max(0,min(9999999,v.cells[ oldInf[1]].population-totalMil)+ oldInf[0]/val1*v.cells[ oldInf[1]].population/22-v.players[v.pId].disease[0]*2*0.16)
   v.cells[oldInf[1]].inGroups[ v.players[v.pId].group]+= (oldInf[0]// val1)//20
   v.players[v.pId] .influences[i][0]= min(1.0,oldInf[0]+ 0.3/val3/ (1+len(v.players[v.pId].claims[0])))
   allInf+= v.players[v.pId] .influences[i][0]
   allCit+= int(v.players[v.pId] .influences[i][0]*v.cells[v.players[v.pId] .influences[i][1]].population)

   if oldInf[0]<0.5:
    if v.players[v.pId] .influences[i][0]>=0.5:
     for idx in checkCross(v.players[v.pId] .influences[i][1]):
      v.players[v.pId]. availableLands.append(idx)
   if len(v.players[v.pId]. availableLands)>0:
    randomLand= random.choice( v.players[v.pId]. availableLands)
    v.players[v.pId].influences. append([0.0,randomLand])
    v.players[v.pId]. availableLands.remove(randomLand)

  alls=[allCit,v.players[v.pId].military, allInf]
  for i in range(3):
   if alls[i]> v.players[v.pId].peaks[i]:
    v.players[v.pId].peaks[i]=alls[i]
  v.players[v.pId].citizens= allCit
  v.buffer=[True]*v.xy[1]
  consoleShow()

def sortWindow(text=[]):
 if v.windowScroll+1>len(text):
  v.windowScroll= min(len(text)-1,v.windowScroll)
  return
 v.windowText= [""]* int(v.xy[1]*0.5)
 for i in range(v.windowScroll,len(text)):
  if len(v.windowText)>i- v.windowScroll:
   v.windowText[(i- v.windowScroll)]+= f"{text[i]}"

def commandFocus():
 newCom=commands[5:8]+aliases[5:8]
 if v.console in newCom:
  v.players[v.pId].focus= newCom.index(v.console)%3

def consoleShow():
 if v.windowState==-1: return
 finalText,added= [],["",""]
 if v.windowState==2:
  added=["", v.players[v.pId].citizens,v.players[v.pId].military, ["none","mild","heavy"][v.players[v.pId].disease[0]]]

 elif v.windowState==3:
  focusStr = " ".join([f"!{word}!" if i == v.players[v.pId].focus else word for i, word in enumerate(commands[5:8])])
  added=["",focusStr]

 elif v.windowState==4:
  allRelations=[]
  for i in range(len(v.players[v.pId].relations)):
   relationAdded=f"n{i} "
   relationText="bad neutral good max"
   if i==v.pId:
    relationText=f"self {v.players[v.pId].relations[i]}"
   elif v.players[v.pId]. relations[i]>=1.0:
    relationText= relationText[:17]+ '>'+ relationText[17:] 
   elif v.players[v.pId]. relations[i]>=0.6:
    relationText= relationText[:12]+ '>'+ relationText[12:] 
   elif v.players[v.pId].relations[i]>=0.3:
    relationText= relationText[:4]+ '>'+ relationText[4:] 
   elif v.players[v.pId]. relations[i]>=0.0:
    relationText='>'+ relationText
   else:
    relationText="???"
   allRelations.append( relationAdded+relationText)
  added=["",allRelations]

 elif v.windowState==5:
  allInf= 0
  for idx in v.players[v.pId].influences:
   allInf+= idx[0]
  peakIdx= v.players[v.pId].peaks
  total= (peakIdx[0]/ 2+peakIdx[1]* peakIdx[2])/3+ (v.players[v.pId].citizens/ 2+v.players[v.pId].military* allInf)
  current=[v.players[v.pId].citizens, v.players[v.pId].military, allInf]
  added=["","", f"{peakIdx}",f"{current}","","", total]

 if v.windowState in [2,3,4]:
  pl= v.players[v.pId]
  allInvs=[]
  for inv in pl.investments:
   if inv.window!=v.windowState-2:
    continue
   allDems=""
   for i in range(3):
    if inv.demands[i]>0.2:
     allDems+="H,"
    elif inv.demands[i]>0.1:
     allDems+="M,"
    elif inv.demands[i]>0.0: 
     allDems+="L,"   
    else: 
     allDems+="0," 
   combindInv= f"{inv.name}:[{allDems}{inv.demands[3]}]"
   allInvs.append(combindInv)
  added.append(allInvs)

 for i in range(max(len(added),len( allTexts[v.windowState]))):
  if i<len(allTexts[v.windowState]):
   finalText.append( allTexts[v.windowState][i])
  if i<len(added):
   if added[i]!="": 
    if isinstance(added[i],list):
     for idx in added[i]:
      finalText.append(idx)
    else:
     finalText.append(added[i])
 sortWindow( finalText) 

def commandFuncs():
 newCom=  commands[:5]+ aliases[:5]
 if v.console in newCom:
  v.windowState= newCom.index(v.console)% 5
 if v.console in [commands[1],aliases[1]]:
  v.pause= not v.pause
 elif v.console==commands[8]:
  createMap()

 else:
  inv= v.players[v.pId]. investments
  for i in range(len(inv)-1,-1,-1):
   access=-1
   if inv[i].code.split()[0]==v.console:
    if len(inv[i].code.split())==1: 
     access=0
    elif inv.code.split()[1]=="n":
     access=1
    elif inv.code.split()[1]=="y":
     access=0
    if access==0:
     inv[i].enabled= True
    elif access==1:
     del inv[i] 

 consoleShow()
 v.console=""
 v.playerConsole=False

def onPress(key):
 try:
  if key== Key.enter:
   v.buffer = [True]* v.xy[1]
   if v.playerConsole:
    if v.console!="":
     v.history[0].insert(0,v.console)
     v.history[0].pop()
     v.history[1]=-1
    commandFuncs()
   else:
    if v.windowState>-1:
     v.windowState=-1
    else: v.playerConsole=True
   cursorVisible()
  if v.playerConsole:
   if key == Key.backspace:
    v.console=v.console[:-1]
   elif hasattr(key, 'char'):
    v.console += key.char.lower()
   elif key== keyboard.Key.space:
    v.console+= ' '
   elif key == Key.up or key== Key.down:
    if key== Key.down: 
     v.history[1]=max(0,v.history[1]-1)
    else:
     v.history[1]= min(len(v.history[0])-1,v.history[1]+1)
    v.debugText=[v.history[0],v.history[1]]
    v.console= v.history[0][v.history[1]]
  else:
   if hasattr(key, 'char'):
    if key.char.lower() == 'a':
     v.mapScroll[0]= max(v.mapScroll[0]-v.xy[0]/10,0)
    elif key.char.lower() == 'd':
     v.mapScroll[0]= max(0,min(v.mapScroll[0]+v.xy[0]/10, v.mapSize[0]-v.xy[0]))
    elif key.char.lower() == 'w':
     v.mapScroll[1]= max(v.mapScroll[1]-v.xy[1]/10,0)
    elif key.char.lower() == 's':
     v.mapScroll[1]= max(0,min(v.mapScroll[1]+v.xy[1]/10, v.mapSize[1]-v.xy[1]+1))
    else:
     modes=['1','2','3','4','5']
     if key.char.lower() in modes:
      modeSet( modes.index(key.char.lower()))
     scroll= ['e','q']
     if key.char.lower() in scroll:
      v.windowScroll= max(0,v.windowScroll+ 1 - scroll.index(key.char.lower())*2)
      consoleShow()
      
    v.mapScroll=[int(i) for i in v.mapScroll]
    v.buffer=[True]* len(v.buffer)

 except Exception as e:
  traceback.print_exc()

def cursorVisible():
 if not v.playerConsole:#hide
  print('\033[?25l', end='', flush=True)
 else:
  print('\033[?25h', end='', flush=True)

def modeSet(mode=-1):
 if mode!=-1: v.mapMode= mode
 validCells = [cel for cel in v.cells if cel is not None]
 if v.mapMode==1:
  v.average= int(sum(cel.population for cel in validCells)/len(validCells))

createMap(v.seed)
cursorVisible()
disableControls()
oldSettings = termios.tcgetattr(sys.stdin)
tty.setcbreak(sys.stdin.fileno())

with Listener(on_press=onPress) as listener:
 try:
  while True:
   size = shutil.get_terminal_size()
   if v.xy!=[size.columns,size.lines]:
    if [size.columns, size.lines]!=[0,0]:
     v.xy=[size.columns, size.lines]
     v.buffer=[True]* v.xy[1] 
     v.windowText=[""]* int(v.xy[1]*0.5)
     consoleShow()

   v.buffer[v.xy[1]-1]=True
   for y in range(v.xy[1]):
    drawLine(y)
   v.delay+=1
   if v.delay> 1000000: v.delay=0
   gameLoop()
   print( f"\033]0;{int(v.scale*1000)}/{v.delay}/{v.windowScroll}/{v.debugText}\007", end='', flush=True)
   time.sleep(0.01)
 finally:
  termios.tcsetattr(sys.stdin, termios.TCSADRAIN, oldSettings)